---

name: Слабая типизация
theory: |

  В модуле «Арифметика» мы затронули тему слабой типизации.

  PHP — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию когда это кажется разумным.

  Особенно много автоматических преобразований происходит при работе с логическими операциями.

  Пример:

  ```php
  <?php

  print_r(0 || 1);
  ```

  <pre class='hexlet-basics-output'>1</pre>

  Существует довольно простой свод правил, по которым происходят данные преобразования:

  * Превращаются в `false`: `0`, `''`, `null` и некоторые другие, не рассмотренные типы данных.
  * В `true` превращается всё остальное.

  И если `null` рассматривается как `false` почти во всех языках, то с остальными значениями не так все просто. В некоторых языках они рассматриваются как `false`, в некоторых как `true`. Не забывайте о том, что PHP — всего лишь один из языков программирования, а не истинна в последней инстанции. То, как реализованы многие вещи в PHP — не пример для подражания, а историческое наследие.

  Справедливо и обратное: `true` и `false` преобразовываются в другие типы данных.

  Например, если сделать `print_r(false)`, то на экран не будет выведено ничего. Потому что PHP при выводе преобразует `false` в пустую строку. А вот `true` преобразуется в строчку `'1'`, поэтому `print_r(true)` выведет на экран `1`.

  ---

  В одном из уроков мы рассмотрели операторы сравнения `===` и `!==` и упомянули, что в PHP так же есть операторы `==` и `!=`, но их не стоит использовать. Отличия как раз заключаются в преобразовании типов:

  ```php
  var_dump('' === false); // => false
  var_dump('' == false);  // => true
  ```

  Пустая строка и `false` — это разные значения, поэтому оператор `===` говорит «ложь! они не равны!».

  Но оператор `==` преобразует типы, и с его точки зрения пустая строка и `false` равны.

  Это преобразование неявное, поэтому по возможности избегайте операторов `==` и `!=`.

  ---

  Вспомните операцию отрицания:

  ```php
  $answer = true;
  var_dump(!$answer);  // => false
  ```

  При двойном отрицании `!!` итоговое значение равно начальному:

  ```php
  $answer = true;
  var_dump(!!$answer);  // => true
  ```

  Но здесь дополнительно происходит преобразования типа. Поэтому результатом двойного отрицания всегда будет _bool_. Этим приемом пользуются, чтобы поменять тип данных.

instructions: |

  Напишите функцию `isFalsy`, которая проверяет, трактуется ли переданное значение как ложное с точки зрения PHP. Для выполнения этой проверке вам понадобится сравнить `false` с переданным значением, используя `==`.

tips:
  - |
    [Booleans](http://php.net/manual/en/language.types.boolean.php)
